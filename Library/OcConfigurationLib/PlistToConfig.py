#!/usr/bin/env python3

#  Copyright (c) 2020, Mike Beaton. All rights reserved.
#  SPDX-License-Identifier: BSD-3-Clause

"""
Generate OpenCore .c and .h plist config definition files from template plist file.
"""

import base64
import io
import os
import sys
import xml.etree.ElementTree as ET

from dataclasses import dataclass

# Available flags for -f:

# show markup with implied types added
SHOW_PLIST = 1 << 0
# show creation of plist schema objects
SHOW_PLIST_SCHEMA = 1 << 1
# show creation of OC schema objects
SHOW_OC_SCHEMA = 1 << 2
# show processing steps
SHOW_DEBUG = 1 << 3
# show additional context used in processing
SHOW_CONTEXT = 1 << 4

flags = 0

# output string buffers
h_types = None
c_structors = None
c_schema = None

# support customisation for other apps
DEFAULT_PREFIX = 'Oc'

camel_prefix = None
upper_prefix = None

SHARED_HEADER = \
'''/** @file
  Copyright (C) 2019-2020, vit9696. All rights reserved.

  All rights reserved.

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
**/

///
/// This file generated by PlistToConfig.py from template .plist file, do not edit
///
'''

C_TEMPLATE = \
'''
#include <Library/OcConfigurationLib.h>
[[BODY]]STATIC
OC_SCHEMA_INFO
mRootConfigurationInfo = {
  .Dict = {mRootConfigurationNodes, ARRAY_SIZE (mRootConfigurationNodes)}
};

EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  )
{
  BOOLEAN  Success;

  [[PREFIX]]_GLOBAL_CONFIG_CONSTRUCT (Config, sizeof (*Config));
  Success = ParseSerialized (Config, &mRootConfigurationInfo, Buffer, Size);

  if (!Success) {
    [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
    return EFI_UNSUPPORTED;
  }

  return EFI_SUCCESS;
}

VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  )
{
  [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
}
'''

H_TEMPLATE = \
'''
#ifndef [[PREFIX]]_CONFIGURATION_LIB_H
#define [[PREFIX]]_CONFIGURATION_LIB_H

#include <Library/DebugLib.h>
#include <Library/OcSerializeLib.h>
#include <Library/OcBootManagementLib.h>
#include <Library/OcConfigurationConstants.h>

[[BODY]]/**
  Initialize configuration with plist data.

  @param[out]  Config   Configuration structure.
  @param[in]   Buffer   Configuration buffer in plist format.
  @param[in]   Size     Configuration buffer size.

  @retval  EFI_SUCCESS on success
**/
EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  );

/**
  Free configuration structure.

  @param[in,out]  Config   Configuration structure.
**/
VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  );

#endif // [[PREFIX]]_CONFIGURATION_LIB_H
'''

##
# Errors and IO
#

column_pos = {}

def tab_print(*args, **kwargs):
  kwargs['end'] = ''
  kwargs['sep'] = ''
  file = kwargs.get('file', sys.stdout)

  pos = column_pos.get(file, 0)

  s = io.StringIO()

  kwargs['file'] = s

  print(*args, **kwargs)
  count = s.tell()
  column_pos[file] = pos + count
  s.seek(0)

  kwargs['file'] = file
  print(s.read(), **kwargs)

  s.close()

def tab_to(col, file):
  pos = column_pos.get(file, 0)
  count = col - pos
  if count > 0:
    column_pos[file] = col
    for _ in range(count):
      print(' ', file=file, end='')

def tab_nl(file):
  column_pos[file] = 0
  print(file=file)

def error(*args, **kwargs):
  print('ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def internal_error(*args, **kwargs):
  print('INTERNAL_ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def debug(*args, **kwargs):
  if flags & SHOW_DEBUG != 0:
    print('DEBUG: ', *args, sep='', **kwargs)

def info_print(*args, **kwargs):
  if kwargs.pop('info_flags', 0) & flags != 0:
    for _ in range(0, kwargs.pop('tab', 0)):
      print(end='\t')
    print(*args, sep='', **kwargs)

def plist_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST, **kwargs)

def plist_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST_SCHEMA, **kwargs)

def oc_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_OC_SCHEMA, **kwargs)

def attr_print(name, value, flags):
  if value is not None:
    info_print(' ', name, '=', info_flags=flags, end='')
    if type(value) is list:
      info_print(value, info_flags=flags, end='')
    elif type(value) is str:
      info_print('"', value, '"', info_flags=flags, end='')
    else:
      info_print(value, info_flags=flags, end='')

def plist_schema_attr_print(name, value):
  attr_print(name, value, SHOW_PLIST_SCHEMA)

def oc_schema_attr_print(name, value):
  attr_print(name, value, SHOW_OC_SCHEMA)

def context_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_CONTEXT, **kwargs)

##
# Emit file elements
#

def emit_section_name(h_name, c_name):
  print('/**', file = h_types)
  print('  %s' % h_name, file = h_types)
  print('**/', file = h_types)
  print(file = h_types)

  print('//', file = c_schema)
  print('// %s' % c_name, file = c_schema)
  print('//', file = c_schema)
  print(file = c_schema)

  print(file = c_structors)

def emit_section(key):
  comment = key.comment
  if comment is None:
    comment = key.value
  emit_section_name('%s section' % comment, '%s configuration support' % comment)

def emit_root_config_section():
  emit_section_name('Root configuration', 'Root configuration')

def upper_path(path):
  return '_'.join(p.upper() for p in path)

def set_def_name(elem, elem_type):
  use_path = elem.path.copy()
  if len(elem.path) == 0:
    use_path.append('GLOBAL')
  if len(elem.path) <= 1:
    use_path.append('CONFIG')
  elif elem_type is not None:
    use_path.append(elem_type)
  upath = upper_path(use_path)
  elem.reference = '%s_%s' % (upper_prefix, upath)

def emit_comment(elem):
  if elem.comment is not None:
    print('///', file = h_types)
    print('/// %s.' % elem.comment, file = h_types)
    print('///', file = h_types)

def emit_field(elem):
  constructor = None
  destructor = '()'

  tab_destructor = 98
  tab_end = 122

  if elem.schema_type == 'OC_STRING':
    constructor = '""'
    constructor = 'OC_STRING_CONSTR (%s, _, __)' % constructor
    destructor = 'OC_DESTR (OC_STRING)'
  elif elem.schema_type == 'BOOLEAN':
    constructor = 'FALSE'
  elif elem.schema_type == 'DATA':
    constructor = '0'
    if elem.size is not None:
      constructor = '{%s}' % constructor
  elif elem.schema_type == 'OC_MAP' or elem.schema_type == 'OC_STRUCT' or elem.schema_type == 'OC_ARRAY':
    constructor = 'OC_CONSTR%d (%s, _, __)' % (len(elem.path), elem.reference)
    destructor = 'OC_DESTR (%s)' % elem.reference
    tab_destructor = 117
    tab_end = 158
  elif elem.schema_type == 'OC_DATA':
    constructor = 'OC_EDATA_CONSTR (_, __)'
    destructor = 'OC_DESTR (OC_DATA)'
  elif elem.schema_type == 'OC_POINTER':
    constructor = 'NULL'
    destructor = 'OcFreePointer'
  else:
    internal_error('Unhandled schema type ', elem.schema_type)

  tab_to(2, file = h_types)
  tab_print('_(', file = h_types)
  tab_print(elem.reference, file = h_types)

  tab_to(36, file = h_types)
  tab_print(', ', elem.name, file = h_types)

  tab_to(62, file = h_types)
  tab_print(', ', file = h_types)
  if elem.size is not None:
    tab_print('[%s]' % elem.size, file = h_types)

  tab_to(67, file = h_types)
  tab_print(' , ', file = h_types)
  if constructor is not None:
    tab_print(constructor, file = h_types)

  tab_to(tab_destructor, file = h_types)
  tab_print(' , ', file = h_types)
  if destructor is not None:
    tab_print(destructor, file = h_types)

  tab_to(tab_end, file = h_types)
  tab_print(')', file = h_types)

def emit_struct(elem, context):
  context_print('STRUCT CONTEXT: ', context)
  if context == 'array':
    set_def_name(elem, 'ENTRY')
  elif context == 'struct':
    set_def_name(elem, None)
  else:
    set_def_name(elem, 'ARRAY')

  if len(elem.path) == 0:
    emit_root_config_section()

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.reference, file = h_types)

  last = len(elem.of) - 1
  for (i, of) in enumerate(elem.of):
    emit_field(of)
    if i < last:
      tab_print(' \\', file = h_types)
    tab_nl(file = h_types)

  print('  OC_DECLARE (%s)' % elem.reference, file = h_types)
  print(file = h_types)

  # .c structors
  print('OC_STRUCTORS       (%s, ())' % elem.reference, file = c_structors)

def emit_array(elem, context):
  context_print('ARRAY CONTEXT: ', context)
  if context == 'map':
    set_def_name(elem, 'ENTRY')
  else:
    set_def_name(elem, 'ARRAY')

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.reference, file = h_types)
  print('  OC_ARRAY (%s, _, __)' % elem.of.reference, file = h_types)
  print('  OC_DECLARE (%s)' % elem.reference , file = h_types)
  print(file = h_types)

  # .c structors
  if context == 'map':
    print('OC_STRUCTORS       (%s, ())' % elem.reference, file = c_structors)
  else:
    print('OC_ARRAY_STRUCTORS (%s)' % elem.reference, file = c_structors)

def emit_map(elem):
  set_def_name(elem, 'MAP')

  emit_comment(elem)

  print('#define %s_FIELDS(_, __) \\' % elem.reference, file = h_types)
  print('  OC_MAP (OC_STRING, %s, _, __)' % elem.of.reference, file = h_types)
  print('  OC_DECLARE (%s)' % elem.reference , file = h_types)
  print(file = h_types)

  # .c structors
  print('OC_MAP_STRUCTORS   (%s)' % elem.reference, file = c_structors)

##
# Schema objects
#

@dataclass
class PlistKey:
  schema_type: str
  comment: str
  remove: bool
  value: str
  path_spec: str
  replace_name: str

  def __init__(
    self,
    comment: str = None,
    remove: str = None,
    value: str = None,
    path_spec: str = None,
    replace_name: str = None,
    tab: int = 0
    ):

    bool_remove = None
    if remove is not None:
      if remove == "0" or remove.lower() == "false":
        bool_remove = False
      else:
        bool_remove = True
    self.schema_type = 'key'
    self.comment = comment
    self.value = value
    self.remove = bool_remove
    self.path_spec = path_spec
    self.replace_name = replace_name

    plist_schema_print('[plist:key', tab=tab, end='')
    plist_schema_attr_print('comment', comment)
    plist_schema_attr_print('value', value)
    plist_schema_attr_print('remove', bool_remove)
    plist_schema_attr_print('path', path_spec)
    plist_schema_attr_print('name', replace_name)
    plist_schema_print(']')

    if path_spec is None:
      self.path_spec = value

@dataclass
class OcSchemaElement:
  schema_type: str
  name: str
  path: str
  data_type: str
  size: str
  comment: str
  value: str
  remove: bool
  default: str
  of: object
  # .h file definition name, once emitted
  reference: str

  def __init__(
    self,
    schema_type: str,
    name: str = None,
    path: str = None,
    size: str = None,
    comment: str = None,
    value: str = None,
    remove: bool = None,
    default: str = None,
    of: object = None,
    reference: str = None,
    tab: int = 0
    ):

    self.schema_type = schema_type
    self.name = name
    self.path = path
    self.size = size
    self.comment = comment
    self.value = value
    self.remove = remove
    self.default = default
    self.of = of
    self.reference = reference

    oc_schema_print('[OC:', schema_type, tab=tab, end='')
    oc_schema_attr_print('name', name)
    oc_schema_attr_print('path', path)
    oc_schema_attr_print('size', size)
    oc_schema_attr_print('comment', comment)
    oc_schema_attr_print('value', value)
    oc_schema_attr_print('remove', remove)
    oc_schema_attr_print('default', default)
    of_type = None
    if of is not None:
      if type(of) is list:
        of_type = 'list[%d]' % len(of)
      else:
        of_type = of.schema_type
    oc_schema_attr_print('of', of_type)
    oc_schema_attr_print('reference', reference)
    oc_schema_print(']')

  def apply_key(
    self,
    key,
    tab = 0
    ):

    name = key.replace_name if key.replace_name is not None else key.value

    if self.name is not None:
      internal_error('name should not get set more than once on OcSchemaElement')
    self.name = name
    oc_schema_print('[OC: ... name="', name, '"', tab=(tab+1), end='')

    self.remove = key.remove
    if self.remove is not None:
      oc_schema_print(' remove=', self.remove, end='')

    oc_schema_print(']')

##
# Parsing
#

def plist_start(elem, tab):
  plist_print('<', elem.tag, end='', tab=tab)

def plist_stop():
  plist_print('>')

def plist_attr(name, value):
  if value is not None:
    plist_print(' ', name, '="', value, '"', end='')

def plist_stop_then_close(elem, contents):
  if contents is not None:
    plist_print('>', contents, '</', elem.tag, '>')
  else:
    plist_print('/>')

def plist_open(elem, tab):
  plist_print('<', elem.tag, '>', tab=tab)

def plist_close(elem, tab):
  plist_print('</', elem.tag, '>', tab=tab)

def plist_open_close(elem, tab):
  plist_start(elem, tab)
  plist_stop_then_close(elem, elem.text)

def consume_attr(elem, name):
  value = elem.attrib.get(name, None)
  plist_attr(name, value)
  return value

def check_key(parent, child, index):
  if child.schema_type != 'key':
    error('<key> required as ', 'first' if index == 0 else 'every even' , ' element of <', parent.tag, '>')

def parse_key(elem, tab):
  if elem.attrib.get('type', None) is not None:
    error('type attribute should be applied to data not key')
    
  if elem.attrib.get('size', None) is not None:
    error('size attribute should be applied to data not key')
    
  plist_start(elem, tab)
  replace_name = consume_attr(elem, 'name')
  path_spec = consume_attr(elem, 'path')
  comment = consume_attr(elem, 'comment')
  remove = consume_attr(elem, 'remove')
  plist_stop_then_close(elem, elem.text)

  return PlistKey(value=elem.text, replace_name=replace_name, path_spec=path_spec, comment=comment, remove=remove, tab=tab)

def parse_pointer(elem, tab, path):
  plist_start(elem, tab)
  to = consume_attr(elem, 'to')
  plist_stop_then_close(elem, None)

  if to is None:
    to = 'uint8'

  reference = '%s *' % to.upper()

  return OcSchemaElement(schema_type='OC_POINTER', tab=tab, path=path, reference=reference)

def parse_data(elem, tab, path, is_integer = False):
  data_type = elem.attrib.get('type', None)
  data_size = elem.attrib.get('size', None)
  data = elem.text

  data_print = None

  if is_integer:
    if data_type is None:
      data_type = 'uint32' # use as default for integer

    if data is not None:
      if data_type == 'uint64':
        data_print = '0x%16x' % int(data)
      elif data_type == 'uint16':
        data_print = '0x%4x' % int(data)
      elif data_type == 'uint8':
        data_print = '0x%2x' % int(data)
      else:
        data_print = '0x%8x' % int(data)
  else:
    if data is not None:
      data_bytes = base64.b64decode(data)
      byte_length = len(data_bytes)
      data_print = '0x' + data_bytes.hex()

      if data_type is None or data_size is None:

        if data_type is None:
          if byte_length == 2:
            data_type = 'uint16'
          elif byte_length == 4:
            data_type = 'uint32'
          elif byte_length == 8:
            data_type = 'uint64'
          else:
            data_type = 'uint8'

        # for data of a definite length with uint8 type we allow implicit array size
        if data_type == 'uint8' and byte_length != 1 and data_size is None:
          data_size = str(byte_length)

  if data_type is None:
    if data_size is None:
      data_type = 'blob'
    else:
      data_type = 'uint8'
  elif data_type == 'blob' and data_size is not None:
    error('size attribute not valid with type="blob"')

  plist_start(elem, tab)
  plist_attr('type', data_type)
  plist_attr('size', data_size)
  plist_stop_then_close(elem, data_print)

  reference = data_type.upper()
  if reference == 'BLOB':
    schema_type = 'OC_DATA'
    reference = 'OC_DATA'
  else:
    schema_type = 'DATA'

  return OcSchemaElement(schema_type=schema_type, size=data_size, value=data_print, tab=tab, path=path, reference=reference)

def skipping(count, tab, used_count = 0):
  skip = count - used_count
  if skip > 0:
    plist_print('(skipping ', skip, ' item', '' if skip == 1 else 's' , ')', tab=(tab + 1))

def parse_array(elem, tab, path, key, context):
  plist_start(elem, tab)
  comment = consume_attr(elem, 'comment')
  xref = consume_attr(elem, 'xref')
  plist_stop()

  count = len(elem)

  if xref is not None:
    skipping(count, tab)
    elem_array = OcSchemaElement(schema_type='OC_ARRAY', tab=tab, path=path, comment=comment, reference=xref)
  else:
    if count == 0:
      error('No template for <array>')

    child = parse_elem(elem[0], tab, path, None, context='array')

    skipping(count, tab, used_count=1)

    elem_array = OcSchemaElement(schema_type='OC_ARRAY', of=child, tab=tab, path=path, comment=comment)
    emit_array(elem_array, context)

  plist_close(elem, tab)

  return elem_array

def init_dict(elem, path, tab, map):
  plist_start(elem, tab=tab)
  plist_attr('type', 'map' if map else None)
  comment = consume_attr(elem, 'comment')
  xref = consume_attr(elem, 'xref')
  new_path = consume_attr(elem, 'path')
  plist_stop()

  count = len(elem)

  if count == 0 and xref is not None:
    error('No elements in <dict>')

  if count % 2 != 0:
    error('Number of nodes in <dict> must be even')

  # used where name of child needs to differ from name of parent
  if new_path is not None:
    replace_path = path.copy()
    del replace_path[-1]
    replace_path.append(new_path)
  else:
    replace_path = path

  return (count >> 1, comment, xref, replace_path)

def parse_map(elem, tab, path, key):
  (count, comment, xref, replace_path) = init_dict(elem, path, tab, True)

  if xref is not None:
    # no particular reason not to add it following the pattern of struct and array, just not (yet?) required
    error('no support for xref in map')

  key = parse_elem(elem[0], tab, path, None)

  check_key(elem, key, 0)

  oc_value = parse_elem(elem[1], tab, path, None, context='map')

  count -= 1

  skipping(count, tab)

  plist_close(elem, tab)

  if oc_value.schema_type == 'OC_DATA':
    return OcSchemaElement(schema_type='OC_ASSOC', tab=tab, path=replace_path, reference = 'OC_ASSOC')
  else:
    elem_map = OcSchemaElement(schema_type='OC_MAP', of=oc_value, tab=tab, path=replace_path, comment=comment)
    emit_map(elem_map)
    return elem_map

def parse_struct(elem, tab, path, key, context):
  (count, comment, xref, replace_path) = init_dict(elem, path, tab, False)

  if xref is not None:
    skipping(count, tab)
    elem_struct = OcSchemaElement(schema_type='OC_STRUCT', tab=tab, path=replace_path, comment=comment, reference=xref)
  else:
    fields = []

    index = 0
    while count > 0:
      key = parse_elem(elem[index], tab, path, None)

      check_key(elem, key, index)

      if key.value is None and key.replace_name is None:
        error('<key> tag within <dict> fields template must have name attribute or xml content to use as variable name')

      if len(path) == 0:
        emit_section(key)

      oc_child = parse_elem(elem[index + 1], tab, path, key.path_spec, context = 'struct')

      oc_child.apply_key(key, tab=tab)

      fields.append(oc_child)

      count -= 1
      index += 2

    elem_struct = OcSchemaElement(schema_type='OC_STRUCT', of=fields, tab=tab, path=replace_path, comment=comment)
    emit_struct(elem_struct, context)

  plist_close(elem, tab)

  return elem_struct

def parse_plist(elem, tab, path, key):
  plist_open(elem, tab)

  count = len(elem)
  if count != 1:
    error('Invalid contents for <plist>')

  child = parse_elem(elem[0], tab, path, None, indent=False)

  plist_close(elem, tab)

  return child

def parse_elem(elem, tab, path, key, indent = True, context = None):
  if tab == None:
    tab = 0

  if indent:
    tab += 1

  context_print('CONTEXT: ', context, tab = tab)
  
  if path is None:
    replace_path = None
  else:
    replace_path = path.copy()
    if key is not None:
      replace_path.append(key) # NB modifies list, returns None

  if elem.tag == 'key':
    return parse_key(elem, tab)

  if elem.tag == 'true' or elem.tag == 'false':
    plist_open_close(elem, tab)
    return OcSchemaElement(schema_type='BOOLEAN', value=elem.tag, tab=tab, path=replace_path, reference='BOOLEAN')

  if elem.tag == 'string':
    plist_open_close(elem, tab)
    return OcSchemaElement(schema_type='OC_STRING', value=elem.text, tab=tab, path=replace_path, reference='OC_STRING')

  if elem.tag == 'integer':
    return parse_data(elem, tab, replace_path, True)

  if elem.tag == 'data':
    return parse_data(elem, tab, replace_path)

  if elem.tag == 'array':
    return parse_array(elem, tab, replace_path, None, context)

  if elem.tag == 'dict':
    if elem.attrib.get('type', None) == 'map':
      return parse_map(elem, tab, replace_path, key)
    else:
      return parse_struct(elem, tab, replace_path, key, context)

  # fake element used to insert pointer to named type
  if elem.tag == 'pointer':
    return parse_pointer(elem, tab, replace_path)

  if elem.tag == 'plist':
    return parse_plist(elem, tab, replace_path, key)

  error('Unhandled tag <', elem.tag, '>')

##
# Utils
#

devnull = open(os.devnull, 'w')

def file_close(handle):
  if handle != devnull and handle != sys.stdout:
    debug('Closing: ', handle)
    handle.close()

def error_on_twice(flag, handle):
  if handle is not None:
    error(flag, ' specified twice')

def customise_template(template, body):
  return template \
    .replace('[[Prefix]]', camel_prefix) \
    .replace('[[PREFIX]]', upper_prefix) \
    .replace('[[BODY]]', body)

##
# Usage, input args, general init
#

# usage
argc = len(sys.argv)
if argc < 2:
  print('PlistToConfig [-c c-file] [-h h-file] [-f print-flags] [-p prefix] plist-file')
  sys.exit(-1)

# file handles
c_file = None
h_file = None

# string buffers
h_types = io.StringIO()
c_structors = io.StringIO()
c_schema = io.StringIO()

# main template filename
plist_filename = None

# parse args
skip = False
for i in range(1, argc):

  if skip:
    
    skip = False
    continue

  arg = sys.argv[i]
  skip = True

  if arg == '-f' or arg == '-p':

    if i + 1 >= argc:
      error('Missing value for ', arg, ' flag')

    if arg == '-f':

      flags = int(sys.argv[i + 1])
      debug('flags = ', flags)

    elif arg == '-p':

      camel_prefix = sys.argv[i + 1]
      debug('prefix = \'', camel_prefix, '\'')

    else:

      internal_error('flag error')

  elif arg == '-c' or arg == '-h':

    if i + 1 >= argc:
      error('Missing file for ', arg)

    flag_filename = sys.argv[i + 1]

    if flag_filename == '-':
      handle = sys.stdout
    elif flag_filename.startswith('-'):
      error('Missing file for ', arg)
    else:
      handle = open(flag_filename, 'w')

    debug(arg, ' ', handle)

    if arg == '-c':
      error_on_twice(arg, c_file)
      c_file = handle
    elif arg == '-h':
      error_on_twice(arg, h_file)
      h_file = handle
    else:
      internal_error('file flag error')

  elif not arg.startswith('-'):

    if plist_filename is not None:
      error('\'', arg, '\': too many input files, already using \'', plist_filename, '\'')

    plist_filename = arg
    debug('input: \'', plist_filename, '\'')
    skip = False

  else:

    error('Unknown flag ', arg)

if plist_filename is None:
  error('No input file')

if camel_prefix is None:
  camel_prefix = DEFAULT_PREFIX
upper_prefix = camel_prefix.upper()

if c_file is None:
  c_file = devnull

if h_file is None:
  h_file = devnull

# ElementTree read plist file into memory
debug('Reading plist XML from \'', plist_filename, '\'')
root = ET.parse(plist_filename).getroot()

# process into string buffers
debug('Parsing plist in memory')
parse_elem(root, None, [], None, indent=False)

# write output
c_structors.seek(0)
c_schema.seek(0)
h_types.seek(0)

debug('Writing c file')
print(SHARED_HEADER, file=c_file, end='')
print(customise_template(C_TEMPLATE, c_structors.read() + '\n' + c_schema.read()), file=c_file, end='')

file_close(c_file)

debug('Writing h file')
print(SHARED_HEADER, file=h_file, end='')
print(customise_template(H_TEMPLATE, h_types.read()), file=h_file, end='')

file_close(h_file)

debug('Done')
sys.exit(0)
