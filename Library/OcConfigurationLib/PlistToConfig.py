#!/usr/bin/env python3

#  Copyright (c) 2020, Mike Beaton. All rights reserved.
#  SPDX-License-Identifier: BSD-3-Clause

"""
Generate OpenCore .c and .h plist config definition files from template plist file.
"""

import base64
import io
import os
import sys
import xml.etree.ElementTree as ET

from dataclasses import dataclass

# Available flags for -f:

# show markup with implied types added
SHOW_PLIST = 0x01
# show creation of plist schema objects
SHOW_PLIST_SCHEMA = 0x02
# show creation of OC schema objects
SHOW_OC_SCHEMA = 0x04
# show processing steps
SHOW_DEBUG = 0x08
# show additional context used in processing
SHOW_CONTEXT = 0x10
# use with SHOW_PLIST to re-create original plist file
# (strips extra args and any hidden or removed elements)
SHOW_ORIGINAL = 0x20

flags = 0

# output string buffers
h_types = None
c_structors = None
c_schema = None

# support customisation for other apps
DEFAULT_PREFIX = 'Oc'

camel_prefix = None
upper_prefix = None

SHARED_HEADER = \
'''/** @file
  Copyright (C) 2019-2020, vit9696. All rights reserved.

  All rights reserved.

  This program and the accompanying materials
  are licensed and made available under the terms and conditions of the BSD License
  which accompanies this distribution.  The full text of the license may be found at
  http://opensource.org/licenses/bsd-license.php

  THE PROGRAM IS DISTRIBUTED UNDER THE BSD LICENSE ON AN "AS IS" BASIS,
  WITHOUT WARRANTIES OR REPRESENTATIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED.
**/

///
/// This file generated by PlistToConfig.py from template .plist file, do not edit
///
'''

C_TEMPLATE = \
'''
#include <Library/OcConfigurationLib.h>
[[BODY]]STATIC
OC_SCHEMA_INFO
mRootConfigurationInfo = {
  .Dict = {mRootConfigurationNodes, ARRAY_SIZE (mRootConfigurationNodes)}
};

EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  )
{
  BOOLEAN  Success;

  [[PREFIX]]_GLOBAL_CONFIG_CONSTRUCT (Config, sizeof (*Config));
  Success = ParseSerialized (Config, &mRootConfigurationInfo, Buffer, Size);

  if (!Success) {
    [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
    return EFI_UNSUPPORTED;
  }

  return EFI_SUCCESS;
}

VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  )
{
  [[PREFIX]]_GLOBAL_CONFIG_DESTRUCT (Config, sizeof (*Config));
}
'''

H_TEMPLATE = \
'''
#ifndef [[PREFIX]]_CONFIGURATION_LIB_H
#define [[PREFIX]]_CONFIGURATION_LIB_H

#include <Library/DebugLib.h>
#include <Library/OcSerializeLib.h>
#include <Library/OcBootManagementLib.h>
#include <Library/OcConfigurationConstants.h>

[[BODY]]/**
  Initialize configuration with plist data.

  @param[out]  Config   Configuration structure.
  @param[in]   Buffer   Configuration buffer in plist format.
  @param[in]   Size     Configuration buffer size.

  @retval  EFI_SUCCESS on success
**/
EFI_STATUS
[[Prefix]]ConfigurationInit (
  OUT [[PREFIX]]_GLOBAL_CONFIG   *Config,
  IN  VOID               *Buffer,
  IN  UINT32             Size
  );

/**
  Free configuration structure.

  @param[in,out]  Config   Configuration structure.
**/
VOID
[[Prefix]]ConfigurationFree (
  IN OUT [[PREFIX]]_GLOBAL_CONFIG   *Config
  );

#endif // [[PREFIX]]_CONFIGURATION_LIB_H
'''

PLIST_HEADER = \
'''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
'''

##
# Errors and IO
#

column_pos = {}

def tab_print(*args, **kwargs):
  kwargs['end'] = ''
  kwargs['sep'] = ''
  file = kwargs.get('file', sys.stdout)

  pos = column_pos.get(file, 0)

  s = io.StringIO()

  kwargs['file'] = s

  print(*args, **kwargs)
  count = s.tell()
  column_pos[file] = pos + count
  s.seek(0)

  kwargs['file'] = file
  print(s.read(), **kwargs)

  s.close()

def tab_to(col, file):
  pos = column_pos.get(file, 0)
  count = col - pos
  if count > 0:
    column_pos[file] = col
    for _ in range(count):
      print(' ', file=file, end='')

def tab_nl(file):
  column_pos[file] = 0
  print(file=file)

def error(*args, **kwargs):
  print('ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def internal_error(*args, **kwargs):
  print('INTERNAL_ERROR: ', *args, sep='', file=sys.stderr, **kwargs)
  sys.exit(-1)

def debug(*args, **kwargs):
  if flags & SHOW_DEBUG != 0:
    print('DEBUG: ', *args, sep='', **kwargs)

def info_print(*args, **kwargs):
  if kwargs.pop('info_flags', 0) & flags != 0:
    for _ in range(0, kwargs.pop('tab', 0)):
      print(end='\t')
    print(*args, sep='', **kwargs)

def plist_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST, **kwargs)

def plist_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_PLIST_SCHEMA, **kwargs)

def oc_schema_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_OC_SCHEMA, **kwargs)

def attr_print(name, value, flags):
  if value is not None:
    info_print(' ', name, '=', info_flags=flags, end='')
    if type(value) is list:
      info_print(value, info_flags=flags, end='')
    elif type(value) is str:
      info_print('"', value, '"', info_flags=flags, end='')
    else:
      info_print(value, info_flags=flags, end='')

def plist_schema_attr_print(name, value):
  attr_print(name, value, SHOW_PLIST_SCHEMA)

def oc_schema_attr_print(name, value):
  attr_print(name, value, SHOW_OC_SCHEMA)

def context_print(*args, **kwargs):
  info_print(*args, info_flags=SHOW_CONTEXT, **kwargs)

##
# Emit file elements
#

@dataclass
class hc:
  h: str
  c: str

  def __init__(self, h=None, c=None):
    self.h = h
    self.c = c

def emit_section_name(h_name, c_name):
  print('/**', file = h_types)
  print('  %s' % h_name, file = h_types)
  print('**/', file = h_types)
  print(file = h_types)

  print('//', file = c_schema)
  print('// %s' % c_name, file = c_schema)
  print('//', file = c_schema)
  print(file = c_schema)

  print(file = c_structors)

def emit_section(key):
  comment = key.comment
  if comment is None:
    comment = key.value
  emit_section_name('%s section' % comment, '%s configuration support' % comment)

def emit_root_config_section():
  emit_section_name('Root configuration', 'Root configuration')

def path_to_ref(path):
  h = '_'.join(p.h for p in path)
  c = ''.join(p.c for p in path)
  return hc(h, c)

def set_reference(elem, elem_name):
  use_path = elem.path.copy()
  root = len(elem.path) == 0
  l1 = len(elem.path) <= 1
  if root:
    use_path.append(hc('GLOBAL', 'Root'))
  if l1:
    use_path.append(hc('CONFIG', 'Configuration%s' % ('Nodes' if root else 'Schema')))
  elif elem_name is not None:
    use_path.append(elem_name)
  hc_path = path_to_ref(use_path)
  elem.ref = hc('%s_%s' % (upper_prefix, hc_path.h), 'm%s' % hc_path.c)

def emit_comment(elem):
  if elem.comment is not None:
    print('///', file = h_types)
    print('/// %s.' % elem.comment, file = h_types)
    print('///', file = h_types)

def emit_field(parent, elem, is_struct, last):
  constructor = None
  destructor = '()'

  default = elem.default

  tab_destructor = 105
  tab_end = 130

  if elem.schema_type == 'STRING':
    if default is None:
      default = '""'
    constructor = 'OC_STRING_CONSTR (%s, _, __)' % default
    destructor = 'OC_DESTR (OC_STRING)' + ' '
  elif elem.schema_type == 'BOOLEAN':
    constructor = 'FALSE'
  elif elem.schema_type == 'DATAF' or elem.schema_type == 'INTEGER':
    if default is None:
      constructor = '0'
    else:
      constructor = default
    if elem.size is not None:
      constructor = '{%s}' % constructor
  elif elem.schema_type == 'MAP' or elem.schema_type == 'STRUCT' or elem.schema_type == 'ARRAY':
    constructor = 'OC_CONSTR%d (%s, _, __)' % (len(elem.path), elem.ref.h)
    destructor = 'OC_DESTR (%s)' % elem.ref.h
    tab_destructor = 112
    tab_end = 149
  elif elem.schema_type == 'DATA':
    constructor = 'OC_EDATA_CONSTR (_, __)'
    destructor = 'OC_DESTR (OC_DATA)' + '   '
  elif elem.schema_type == 'POINTER':
    constructor = 'NULL'
    destructor = 'OcFreePointer' + ' '
  else:
    internal_error('Unhandled schema type ', elem.schema_type)

  # .h
  tab_to(2, file = h_types)
  tab_print('_(', file = h_types)
  tab_print(elem.ref.h, file = h_types)

  tab_to(36, file = h_types)
  tab_print(', ', elem.name, file = h_types)

  tab_to(62, file = h_types)
  tab_print(', ', file = h_types)
  if elem.size is not None:
    tab_print('[%s]' % elem.size, file = h_types)

  tab_to(67, file = h_types)
  tab_print(' , ', file = h_types)
  if constructor is not None:
    tab_print(constructor, file = h_types)

  tab_to(tab_destructor, file = h_types)
  tab_print(' , ', file = h_types)
  if destructor is not None:
    tab_print(destructor, file = h_types)

  tab_print(')', file = h_types)

  if not last:
    tab_to(tab_end, file = h_types)
    tab_print(' \\', file = h_types)

  tab_nl(file = h_types)

  # .c
  if elem.remove:
    return

  if elem.schema_type == 'POINTER':
    error('element <pointer> cannot appear in .c or .plist output, requires remove="true" on preceding key')

  tab_to(2, file = c_schema)
  tab_print('OC_SCHEMA_%s_IN' % elem.schema_type, file = c_schema);
  tab_to(23, file = c_schema)
  tab_print(' ("%s",' % elem.name, file = c_schema)
  tab_to(51, file = c_schema)
  if is_struct:
    tab_print(' %s_GLOBAL_CONFIG,' % upper_prefix, file = c_schema)
  else:
    tab_print(' %s,' % parent.ref.h, file = c_schema)
  tab_to(70, file = c_schema)
  if is_struct:
    tab_print(' %s' % '.'.join(p.c for p in elem.path), file = c_schema)
  else:
    tab_print(' %s' % elem.name, file = c_schema)

  if elem.schema_type == 'ARRAY':
    tab_print(', &%s' % elem.ref.c, file = c_schema)

  tab_print('),', file = c_schema)

  tab_nl(file = c_schema)

def emit_struct(elem, context):
  # skipped elements when outputting original plist
  if elem.path is None:
    return

  context_print('STRUCT CONTEXT: ', context)
  if context == 'array':
    set_reference(elem, hc('ENTRY', 'SchemaEntry'))
  elif context == 'struct':
    set_reference(elem, None)
  else:
    set_reference(elem, hc('ARRAY', 'Array'))

  if len(elem.path) == 0:
    emit_root_config_section()

  emit_comment(elem)

  # .h
  print('#define %s_FIELDS(_, __) \\' % elem.ref.h, file = h_types)

  # .c schema

  if flags & (SHOW_CONTEXT | SHOW_DEBUG) == (SHOW_CONTEXT | SHOW_DEBUG):
    print('// STRUCT CONTEXT: %s' % context, file = c_schema)

  print('STATIC', file = c_schema)
  print('OC_SCHEMA', file = c_schema)
  print('%s[] = {' % elem.ref.c, file = c_schema)

  is_struct = context == 'struct'
  last = len(elem.of) - 1
  for (i, of) in enumerate(elem.of):
    emit_field(elem, of, is_struct, i == last)

  # .h
  print('  OC_DECLARE (%s)' % elem.ref.h, file = h_types)
  print(file = h_types)

  # .c schema
  print('};', file = c_schema)
  print(file = c_schema)

  # .c structors
  print('OC_STRUCTORS       (%s, ())' % elem.ref.h, file = c_structors)

def emit_array(elem, context):
  # skipped elements when outputting original plist
  if elem.path is None:
    return

  context_print('ARRAY CONTEXT: ', context)
  if context == 'map':
    set_reference(elem, hc('ENTRY', 'Entry'))
  else:
    set_reference(elem, hc('ARRAY', 'Schema'))

  emit_comment(elem)

  # .h
  print('#define %s_FIELDS(_, __) \\' % elem.ref.h, file = h_types)
  print('  OC_ARRAY (%s, _, __)' % elem.of.ref.h, file = h_types)
  print('  OC_DECLARE (%s)' % elem.ref.h , file = h_types)
  print(file = h_types)

  # .c

  if flags & (SHOW_CONTEXT | SHOW_DEBUG) == (SHOW_CONTEXT | SHOW_DEBUG):
    print('// ARRAY CONTEXT: %s' % context, file = c_schema)

  print('STATIC', file = c_schema)
  print('OC_SCHEMA', file = c_schema)
  print('%s = OC_SCHEMA_DICT (NULL, %s);' % (elem.ref.c, elem.of.ref.c), file = c_schema)
  print(file = c_schema)

  # .c structors
  if context == 'map':
    print('OC_STRUCTORS       (%s, ())' % elem.ref.h, file = c_structors)
  else:
    print('OC_ARRAY_STRUCTORS (%s)' % elem.ref.h, file = c_structors)

def emit_map(elem):
  # skipped elements when outputting original plist
  if elem.path is None:
    return

  set_reference(elem, hc('MAP', 'Map'))

  emit_comment(elem)

  # .h
  print('#define %s_FIELDS(_, __) \\' % elem.ref.h, file = h_types)
  print('  OC_MAP (OC_STRING, %s, _, __)' % elem.of.ref.h, file = h_types)
  print('  OC_DECLARE (%s)' % elem.ref.h , file = h_types)
  print(file = h_types)

  # .c schema

  if flags & (SHOW_CONTEXT | SHOW_DEBUG) == (SHOW_CONTEXT | SHOW_DEBUG):
    print('// MAP CONTEXT: %s' % None, file = c_schema)

  print(file = c_schema)

  # .c structors
  print('OC_MAP_STRUCTORS   (%s)' % elem.ref.h, file = c_structors)

##
# Schema objects
#

def str_to_bool(str_bool):
  if str_bool is None:
    bool_bool = None
  else:
    lower = str_bool.lower()
    if str_bool == "0" or lower == "false" or lower == "no":
      bool_bool = False
    elif str_bool == "1" or lower == "true" or lower == "yes":
      bool_bool = True
    else:
      error('illegal bool value="', str_bool, '"')
  return bool_bool

@dataclass
class PlistKey:
  schema_type: str
  comment: str
  remove: bool
  hide: bool
  value: str
  node: str
  replace_name: str

  def __init__(
    self,
    comment: str = None,
    remove: bool = None,
    hide: bool = None,
    value: str = None,
    node: hc = None,
    replace_name: str = None,
    tab: int = 0
    ):

    self.schema_type = 'key'
    self.comment = comment
    self.value = value
    self.remove = remove
    self.hide = hide
    self.node = node
    self.replace_name = replace_name

    plist_schema_print('[plist:key', tab=tab, end='')
    plist_schema_attr_print('comment', comment)
    plist_schema_attr_print('value', value)
    plist_schema_attr_print('remove', remove)
    plist_schema_attr_print('hide', hide)
    plist_schema_attr_print('node', node)
    plist_schema_attr_print('name', replace_name)
    plist_schema_print(']')

@dataclass
class OcSchemaElement:
  schema_type: str
  name: str
  path: hc
  data_type: str
  size: str
  comment: str
  value: str
  remove: bool
  default: str
  of: object
  # .h file definition name, once emitted
  ref: hc

  def __init__(
    self,
    schema_type: str,
    name: str = None,
    path: hc = None,
    size: str = None,
    comment: str = None,
    value: str = None,
    remove: bool = None,
    default: str = None,
    of: object = None,
    ref: hc = None,
    tab: int = 0
    ):

    self.schema_type = schema_type
    self.name = name
    self.path = path
    self.size = size
    self.comment = comment
    self.value = value
    self.remove = remove
    self.default = default
    self.of = of
    self.ref = ref

    oc_schema_print('[OC:', schema_type, tab=tab, end='')
    oc_schema_attr_print('name', name)
    oc_schema_attr_print('path', path)
    oc_schema_attr_print('size', size)
    oc_schema_attr_print('comment', comment)
    oc_schema_attr_print('value', value)
    oc_schema_attr_print('remove', remove)
    oc_schema_attr_print('default', default)
    of_type = None
    if of is not None:
      if type(of) is list:
        of_type = 'list[%d]' % len(of)
      else:
        of_type = of.schema_type
    oc_schema_attr_print('of', of_type)
    oc_schema_attr_print('ref', ref)
    oc_schema_print(']')

  def apply_key(
    self,
    key,
    tab = 0
    ):

    name = key.replace_name if key.replace_name is not None else key.value

    if self.name is not None:
      internal_error('name should not get set more than once on OcSchemaElement')
    self.name = name
    oc_schema_print('[OC: ... name="', name, '"', tab=(tab+1), end='')

    self.remove = key.remove
    if self.remove is not None:
      oc_schema_print(' remove=', self.remove, end='')

    oc_schema_print(']')

##
# Parsing
#

def plist_start(elem, tab, hide):
  if hide != True:
    plist_print('<', elem.tag, end='', tab=tab)

def plist_stop(hide):
  if hide != True:
    plist_print('>')

def plist_attr(name, value, hide, always = False):
  if hide != True:
    if (always or flags & SHOW_ORIGINAL == 0) and value is not None:
      plist_print(' ', name, '="', value, '"', end='')

def plist_stop_then_close(elem, contents, hide, quick_close = False):
  if hide != True:
    if contents is not None:
      plist_print('>', contents, '</', elem.tag, '>')
    else:
      if quick_close or flags & SHOW_ORIGINAL == 0:
        plist_print('/>')
      else:
        # for when we need to non-quick-close to match original
        plist_print('></', elem.tag, '>')

def plist_open(elem, tab, hide):
  if hide != True:
    plist_print('<', elem.tag, '>', tab=tab)

def plist_close(elem, tab, hide):
  if hide != True:
    plist_print('</', elem.tag, '>', tab=tab)

def plist_open_close(elem, tab, hide, quick_close = False):
  plist_start(elem, tab, hide)
  plist_stop_then_close(elem, elem.text, hide, quick_close)

def consume_attr(elem, name, hide):
  value = elem.attrib.get(name, None)
  plist_attr(name, value, hide)
  return value

def check_key(parent, child, index):
  if child.schema_type != 'key':
    error('<key> required as ', 'first' if index == 0 else 'every even' , ' element of <', parent.tag, '>')

def parse_key(elem, tab, hide):
  if elem.attrib.get('type', None) is not None:
    error('type attribute should be applied to data not key')
    
  if elem.attrib.get('size', None) is not None:
    error('size attribute should be applied to data not key')

  # indicates an element which should go into the .h file, but not the .c nor the regenerated .plist
  str_remove = elem.attrib.get('remove', None)
  remove = str_to_bool(str_remove)

  # do not allow non-hidden element to reset if already in hidden tree
  if hide != True:
    hide = remove
  
  replace_name = consume_attr(elem, 'name', hide)
  h_node = consume_attr(elem, 'node', hide)
  comment = consume_attr(elem, 'comment', hide)
  plist_attr('remove', str_remove, hide)
  plist_stop_then_close(elem, elem.text, hide)

  if replace_name is not None:
    c_node = replace_name
  else:
    c_node = elem.text

  if h_node is None:
    h_node = c_node

  return PlistKey(value=elem.text, replace_name=replace_name, node=hc(h_node.upper(), c_node), comment=comment, remove=remove, hide=hide, tab=tab)

def parse_boolean(elem, tab, path, hide):
  default = consume_attr(elem, 'default', hide)
  plist_stop_then_close(elem, elem.text, hide, quick_close = True)
  return OcSchemaElement(schema_type='BOOLEAN', value=elem.tag, default=default, tab=tab, path=path, ref=hc('BOOLEAN'))

def parse_string(elem, tab, path, hide):
  default = consume_attr(elem, 'default', hide)
  if default is not None:
    default = '"%s"' % default

  const = consume_attr(elem, 'const', hide)
  if const is not None:
    if default is not None:
      error('do not specify both default and const on <string>')
    default = const

  plist_stop_then_close(elem, elem.text, hide)
  return OcSchemaElement(schema_type='STRING', value=elem.text, default=default, tab=tab, path=path, ref=hc('OC_STRING'))

def parse_pointer(elem, tab, path, hide):
  to = consume_attr(elem, 'to', hide)
  plist_stop_then_close(elem, None, hide)

  if to is None:
    to = 'uint8'

  ref = '%s *' % to.upper()

  return OcSchemaElement(schema_type='POINTER', tab=tab, path=path, ref=hc(ref))

def parse_data(elem, tab, path, hide, is_integer = False):
  data_type = elem.attrib.get('type', None)
  data_size = elem.attrib.get('size', None)
  default = elem.attrib.get('default', None)
  data = elem.text

  data_print = None

  if is_integer:
    if data_type is None:
      data_type = 'uint32' # use as default for integer

    if data is not None:
      if data_type == 'uint64':
        data_print = '0x%16x' % int(data)
      elif data_type == 'uint16':
        data_print = '0x%4x' % int(data)
      elif data_type == 'uint8':
        data_print = '0x%2x' % int(data)
      else:
        data_print = '0x%8x' % int(data)
  else:
    if data is not None:
      data_bytes = base64.b64decode(data)
      byte_length = len(data_bytes)
      data_print = '0x' + data_bytes.hex()

      if data_type is None or data_size is None:

        if data_type is None:
          if byte_length == 2:
            data_type = 'uint16'
          elif byte_length == 4:
            data_type = 'uint32'
          elif byte_length == 8:
            data_type = 'uint64'
          else:
            data_type = 'uint8'

        # for data of a definite length with uint8 type we allow implicit array size
        if data_type == 'uint8' and byte_length != 1 and data_size is None:
          data_size = str(byte_length)

  if data_type is None:
    if data_size is None:
      data_type = 'blob'
    else:
      data_type = 'uint8'
  elif data_type == 'blob' and data_size is not None:
    error('size attribute not valid with type="blob"')

  plist_attr('type', data_type, hide)
  plist_attr('size', data_size, hide)
  plist_attr('default', default, hide)
  plist_stop_then_close(elem, data if flags & SHOW_ORIGINAL != 0  else data_print, hide)

  ref = data_type.upper()
  if ref == 'BLOB':
    schema_type = 'DATA'
    ref = 'OC_DATA'
  else:
    schema_type = 'INTEGER' if is_integer else 'DATAF'

  return OcSchemaElement(schema_type=schema_type, size=data_size, value=data_print, default=default, tab=tab, path=path, ref=hc(ref))

def skipping(elem, index, count, hide, tab):
  if flags & SHOW_ORIGINAL != 0:
    for i in range(index, count):
      # nuke path from here down, which supresses all emit output
      parse_elem(elem[i], tab, None, hide)
  elif hide != True:
    skip = count - index
    if skip > 0:
      plist_print('(skipping ', skip, ' item', '' if skip == 1 else 's' , ')', tab=(tab + 1))

def parse_array(elem, tab, path, hide, hide_children, context):
  comment = consume_attr(elem, 'comment', hide)
  xref = consume_attr(elem, 'xref', hide)

  if hide_children:
    plist_stop_then_close(elem, None, hide, True)
  else:
    plist_stop(hide)

  count = len(elem)
  index = 0

  if xref is not None:
    elem_array = OcSchemaElement(schema_type='ARRAY', tab=tab, path=path, comment=comment, ref=hc(xref))
  else:
    if count == 0:
      error('No template for <array>')

    child = parse_elem(elem[index], tab, path, hide_children, context='array')
    index += 1

    elem_array = OcSchemaElement(schema_type='ARRAY', of=child, tab=tab, path=path, comment=comment)
    emit_array(elem_array, context)

  skipping(elem, index, count, hide_children, tab)

  if not hide_children:
    plist_close(elem, tab, hide)

  return elem_array

def add_warnings(hide):
  if hide != True and flags & SHOW_ORIGINAL != 0:
    plist_print('\t<key>#WARNING - 1</key>')
    plist_print('\t<string>This is just a sample. Do NOT try loading it.</string>')
    plist_print('\t<key>#WARNING - 2</key>')
    plist_print('\t<string>Ensure you understand EVERY field before booting.</string>')
    plist_print('\t<key>#WARNING - 3</key>')
    plist_print('\t<string>In most cases recommended to use Sample.plist</string>')
    plist_print('\t<key>#WARNING - 4</key>')
    plist_print('\t<string>Use SampleCustom.plist only for special cases.</string>')

def init_dict(elem, path, hide, hide_children, tab, map):
  plist_attr('type', 'map' if map else None, hide)
  comment = consume_attr(elem, 'comment', hide)
  xref = consume_attr(elem, 'xref', hide)
  node = consume_attr(elem, 'node', hide)

  if hide_children:
    plist_stop_then_close(elem, None, hide, True)
  else:
    plist_stop(hide)


  if path is not None and len(path) == 0:
    add_warnings(hide)

  count = len(elem)

  if count == 0 and xref is not None:
    error('No elements in <dict>')

  if count % 2 != 0:
    error('Number of nodes in <dict> must be even')

  # used where name of child needs to differ from name of parent
  if node is not None:
    replace_path = path.copy()
    del replace_path[-1]
    replace_path.append(hc(node, node))
  else:
    replace_path = path

  return (count, comment, xref, replace_path)

def parse_map(elem, tab, path, hide, hide_children):
  (count, comment, xref, replace_path) = init_dict(elem, path, hide, hide_children, tab, True)

  if xref is not None:
    # no particular reason not to add it here (following the pattern of struct and array) afaik, just not required yet
    internal_error('support for xref in map not yet added')

  index = 0

  key = parse_elem(elem[index], tab, path, hide_children)
  index += 1

  check_key(elem, key, 0)

  hide_field = hide_children or key.hide

  oc_value = parse_elem(elem[index], tab, path, hide_field, context='map')
  index += 1

  skipping(elem, index, count, hide_children, tab)

  if not hide_children:
    plist_close(elem, tab, hide)

  if oc_value.schema_type == 'DATA':
    return OcSchemaElement(schema_type='OC_ASSOC', tab=tab, path=replace_path, ref = hc('OC_ASSOC'))
  else:
    elem_map = OcSchemaElement(schema_type='MAP', of=oc_value, tab=tab, path=replace_path, comment=comment)
    emit_map(elem_map)
    return elem_map

def parse_struct(elem, tab, path, hide, hide_children, context):
  (count, comment, xref, replace_path) = init_dict(elem, path, hide, hide_children, tab, False)

  index = 0
  if xref is not None:
    elem_struct = OcSchemaElement(schema_type='STRUCT', tab=tab, path=replace_path, comment=comment, ref=hc(xref))
  else:
    fields = []

    while index < count:
      key = parse_elem(elem[index], tab, path, hide_children)
      index += 1

      check_key(elem, key, index)

      # remove means .h but .not .c or .plist; hide means .h and .c but not .plist
      hide_field = hide_children or key.hide or (flags & SHOW_ORIGINAL != 0 and key.remove)

      if key.value is None and key.replace_name is None:
        error('<key> tag within <dict> fields template must have name attribute or xml content to use as variable name')

      if path is not None and len(path) == 0:
        emit_section(key)

      oc_child = parse_elem(elem[index], tab, path, hide_field, next_node=key.node, context='struct')
      index += 1

      oc_child.apply_key(key, tab=tab)

      fields.append(oc_child)

    elem_struct = OcSchemaElement(schema_type='STRUCT', of=fields, tab=tab, path=replace_path, comment=comment)
    emit_struct(elem_struct, context)

  skipping(elem, index, count, hide_children, tab)
  
  if not hide_children:
    plist_close(elem, tab, hide)

  return elem_struct

def parse_plist(elem, tab, path, hide):
  if flags & SHOW_ORIGINAL != 0:
    plist_attr('version', '1.0', hide, True)

  plist_stop(hide)

  count = len(elem)
  if count != 1:
    error('Invalid contents for <plist>')

  child = parse_elem(elem[0], tab, path, hide, indent=False)

  plist_close(elem, tab, hide)

  return child

def parse_elem(elem, tab, path, hide, next_node = None, indent = True, context = None):
  if tab == None:
    tab = 0

  if indent:
    tab += 1

  context_print('CONTEXT: ', context, tab = tab)
  
  if path is None:
    replace_path = None
  else:
    # copy even if not modifying here (children may modify, we don't want to share)
    replace_path = path.copy()

    if next_node is not None:
      replace_path.append(next_node) # append modifies list, returns None

  # shared processing
  hide_children = None
  hide_attr = elem.attrib.get('hide', None)
  if hide_attr is not None:
    if hide_attr.lower() == "children":
      if not (elem.tag == 'array' or elem.tag == 'dict'):
        error('hide="children" only valid on <array> or <dict> - found on <', elem.tag, '>')
      hide_children = True
    else:
      if elem.tag != 'key':
          error('hide attr for properties should be on <key> - found on <', elem.tag, '>')

      if hide != True:
        hide = str_to_bool(hide_attr)
  hide_children = hide_children or hide
  remove_attr = elem.attrib.get('remove', None)
  remove = str_to_bool(remove_attr)
  plist_start(elem, tab, hide or remove)

  if elem.tag == 'key':
    return parse_key(elem, tab, hide)

  if elem.tag == 'true' or elem.tag == 'false':
    return parse_boolean(elem, tab, replace_path, hide)

  if elem.tag == 'string':
    return parse_string(elem, tab, replace_path, hide)

  if elem.tag == 'integer':
    return parse_data(elem, tab, replace_path, hide, True)

  if elem.tag == 'data':
    return parse_data(elem, tab, replace_path, hide)

  if elem.tag == 'array':
    return parse_array(elem, tab, replace_path, hide, hide_children, context)

  if elem.tag == 'dict':
    if elem.attrib.get('type', None) == 'map':
      return parse_map(elem, tab, replace_path, hide, hide_children)
    else:
      return parse_struct(elem, tab, replace_path, hide, hide_children, context)

  # fake element used to insert pointer to named type
  if elem.tag == 'pointer':
    return parse_pointer(elem, tab, replace_path, hide)

  if elem.tag == 'plist':
    return parse_plist(elem, tab, replace_path, hide)

  error('Unhandled tag <', elem.tag, '>')

##
# Utils
#

devnull = open(os.devnull, 'w')

def file_close(handle):
  if handle != devnull and handle != sys.stdout:
    debug('Closing: ', handle)
    handle.close()

def error_on_twice(flag, handle):
  if handle is not None:
    error(flag, ' specified twice')

def customise_template(template, body):
  return template \
    .replace('[[Prefix]]', camel_prefix) \
    .replace('[[PREFIX]]', upper_prefix) \
    .replace('[[BODY]]', body)

##
# Usage, input args, general init
#

# usage
argc = len(sys.argv)
if argc < 2:
  print('PlistToConfig [-c c-file] [-h h-file] [-f print-flags] [-p prefix] plist-file')
  sys.exit(-1)

# file handles
c_file = None
h_file = None

# string buffers
h_types = io.StringIO()
c_structors = io.StringIO()
c_schema = io.StringIO()

# main template filename
plist_filename = None

# parse args
skip = False
for i in range(1, argc):

  if skip:
    
    skip = False
    continue

  arg = sys.argv[i]
  skip = True

  if arg == '-f' or arg == '-p':

    if i + 1 >= argc:
      error('Missing value for ', arg, ' flag')

    if arg == '-f':

      str_f = sys.argv[i + 1]
      if str_f.lower().startswith('0x'):
        flags = int(str_f, 16)
      else:
        flags = int(str_f)
      debug('flags = 0x%x' % flags)

    elif arg == '-p':

      camel_prefix = sys.argv[i + 1]
      debug('prefix = \'', camel_prefix, '\'')

    else:

      internal_error('flag error')

  elif arg == '-c' or arg == '-h':

    if i + 1 >= argc:
      error('Missing file for ', arg)

    flag_filename = sys.argv[i + 1]

    if flag_filename == '-':
      handle = sys.stdout
    elif flag_filename.startswith('-'):
      error('Missing file for ', arg)
    else:
      handle = open(flag_filename, 'w')

    debug(arg, ' ', handle)

    if arg == '-c':
      error_on_twice(arg, c_file)
      c_file = handle
    elif arg == '-h':
      error_on_twice(arg, h_file)
      h_file = handle
    else:
      internal_error('file flag error')

  elif not arg.startswith('-'):

    if plist_filename is not None:
      error('\'', arg, '\': too many input files, already using \'', plist_filename, '\'')

    plist_filename = arg
    debug('input: \'', plist_filename, '\'')
    skip = False

  else:

    error('Unknown flag ', arg)

if plist_filename is None:
  error('No input file')

if camel_prefix is None:
  camel_prefix = DEFAULT_PREFIX
upper_prefix = camel_prefix.upper()

if c_file is None:
  c_file = devnull

if h_file is None:
  h_file = devnull

# ElementTree read plist file into memory
debug('Reading plist XML from \'', plist_filename, '\'')
root = ET.parse(plist_filename).getroot()

# process into string buffers
debug('Parsing plist in memory')
if flags & SHOW_ORIGINAL != 0:
  plist_print(PLIST_HEADER, end='')
parse_elem(root, None, [], False, indent=False)

# write output
c_structors.seek(0)
c_schema.seek(0)
h_types.seek(0)

debug('Writing c file')
print(SHARED_HEADER, file=c_file, end='')
print(customise_template(C_TEMPLATE, c_structors.read() + '\n' + c_schema.read()), file=c_file, end='')

file_close(c_file)

debug('Writing h file')
print(SHARED_HEADER, file=h_file, end='')
print(customise_template(H_TEMPLATE, h_types.read()), file=h_file, end='')

file_close(h_file)

debug('Done')
sys.exit(0)
